{- ILC Standard Prelude -}

letrec map f lst =
    match lst with
    | []   => []
    | x:xs => (f x) : (map f xs)

letrec filter f lst =
    match lst with
    | []            => []
    | x:xs when f x => x : (filter f xs)
    | _:xs          => filter f xs

letrec foldl f acc lst =
    match lst with
    | []   => acc
    | x:xs => foldl f (f acc x) xs

{-letrec foldl1 f lst =
    match lst with
    | []   => "error: empty list"
    | x:xs => foldl f x xs-}

letrec scanl f s lst =
  s : (match lst with
       | []    => []
       | x:xs => scanl f (f s x) xs)

letrec scanl1 f lst =
    match lst with
    | []   => []
    | x:xs => scanl f x xs

letrec foldr f lst acc =
    match lst with
    | []   => acc
    | x:xs => f x (foldr f xs acc)

{-letrec foldr1 f lst =
  match lst with
  | [] => "error: empty list"
  | x:xxs => foldr f xs s-}
  
{- TODO: scanr, scanr1 -}

letrec all f lst =
    match lst with
    | []            => true
    | x:xs when f x => all f xs
    | _             => false

letrec any f lst =
    match lst with
    | []            => false
    | x:xs when f x => true
    | _:xs          => any f xs

letrec nth n lst =
    match (n, lst) with
    {-| (_, []) => "not found"-}
    | (1, x:xs)  => x
    | (n', x:xs) => nth (n'-1) xs

letrec take n lst =
    match lst with
    {-| [] => "error"-}
    | x:xs when n == 1 => [x]
    | x:xs             => x : (take (n-1) xs)

letrec drop n lst =
    match lst with
    | []               => []
    | x:xs when n <= 0 => x:xs {- TODO -}
    | x:xs when        => drop (n-1) xs
  
{-  
let splitAt = lam n, lst .
  (take n lst, drop n lst)
in
let takeWhile = lam f, lst .
  match lst with
  | [] => []
  | x::xs => if f x then x :: (takeWhile f xs)
             else takeWhile f xs
  end
in
let dropWhile = lam f, lst .
  match lst with
  | [] => []
  | x::xs => if f x then dropWhile f xs
             else x::xs
  end
in
let zip = lam lst1, lst2 .
  match (lst1, lst2) with
  | ([], _) => []
  | (_, []) => []
  | (x::xs, y::ys) => (x, y) :: (zip xs ys)
  end
in
let foldr = lam f, lst, acc .
  match lst with
  | [] => acc
  | x::xs => f x (foldr f xs acc)
  end
in
let null = lam lst .
  match lst with
  | [] => true
  | _ => false
  end
in
let sum = lam lst .
  match lst with
  | [] => 0
  | x::xs => x + sum xs
  end
in
let product = lam lst .
  match lst with
  | [] => 0
  | x::xs => x + product xs
  end
in
let min = lam x, y .
  if x < y then x else y
in
let max = lam x, y .
  if x > y then x else y
in
let minimum = lam lst .
  foldl1 min lst
in
let maximum = lam lst .
  foldl1 max lst
in
let init = lam lst .
  match lst with
  | [x] => []
  | x::xs => x :: (init xs)
  end
in
let replicate = lam n, x .
  match n with
  | 0 => []
  | n' => x :: replicate (n'-1) x
  end
in
let getBits = lam n .
  match n with
  | 0 => []
  | n => getBit () :: getBits (n-1)
  end
in
(* TODO: span, break *)
let insert = lam elem, lst .
  match lst with
  | [] => [elem]
  | x::xs => if elem < x then elem :: x :: xs
             else x :: (insert elem xs)
  end
in
let sort = lam lst .
  match lst with
  | [] => []
  | x::xs => insert x (sort xs)
  end
in ()-}