(* SID :: (string, string) *)
(* Crupt :: [pid] *)
let execUC = lam e, p, f, a .
  nu z2p, p2z,
     z2f, f2z,
     z2a, a2z,
     p2f, f2p,
     p2a, a2p,
     a2f, f2a,
     z2exec . (
       (* e chooses sid, corrupted parties *)
       (* partyMap :: [(pid, chan)] ref *)
       let partyMap := [] ;
       let newParty = lam pid .
         nu f2pp, z2pp .
           (let partyMap := (pid, [("f2p", f2pp), ("z2p", z2pp)]) :: partyMap) in
       let getParty = lam pid .
         if (not (mem b partyMap)) then newParty pid ;
         partyMap.pid in
       let loop1 =
         let (pid, m) = rd z2p in
           if (mem pid crupt) then wr (pid, m) -> p2a
             else wr m -> (getParty pid).z2p ; loop1 in
       let loop2 = 
         let (pid, m) = rd f2p in
           if (mem pid crupt) then wr (pid, m) -> p2a
             else wr m -> (getParty pid).f2p ; loop2 in
       let loop3 =
         let (pid, m) = rd a2p in
           if (mem pid crupt) then wr (pid, m) -> p2f ; loop3 in
       let loop4 =
         let (pid, m) = rd a2fp in
           if (mem pid crupt) then wr (pid, m) -> p2z ; loop4 in
       ( loop1 .|. loop2 .|. loop3 .|. loop4 )
     )
in 0