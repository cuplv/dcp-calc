let partyWrapper = lam sid, p, crupt .
  let partyMap = ref [] in
  let newParty = lam pid .
    nu pp2f, pp2z .
      let partyMap := (pid, [("f2p", f2pid), ("z2p", z2pid)]) :: @partyMap ;
      |> (letrec loop =
            let m = rd pp2f in
              wr (pid, m) -> ?p2f ;
              loop in loop) ;
      |> (letrec loop =
            let m = rd pp2z in
              wr (pid, m) -> ?p2z ;
              loop in loop) ;
      |> (p pid pp2f pp2z)
  in
  let getParty = lam pid .
    if (not (mem pid @partyMap)) then newParty pid ;
    @partyMap.pid
  in
  (* Route messages from env to honest parties *)
  |> (letrec fwd_z2p =
        let (pid, m) = rd ?z2p in
          if (mem pid corrupt)
          then wr (pid, m) -> p2a
          else wr m -> (getParty pid)."z2p" ;
          fwd_z2p in fwd_z2p) ;
  (* Route messages from func to honest parties *)
  |> (letrec fwd_f2p = 
       let (pid, m) = rd ?f2p in
         if (mem pid corrupt)
         then wr (pid, m) -> p2a
         else wr m -> (getParty pid)."f2p" ;
         fwdf2p in fwdf2p) ;
  (* Forward messages to corrupt parties to func *)
  |> (letrec fwd_2c2f =
        let (pid, m) = rd a2p in
          if (mem pid corrupt)
          then wr (pid, m) -> p2f ;
          fwd_2c2f in fwd_2c2f) ;
  |> (letrec fwd_2c2z =
        let (pid, m) = rd a2p in
          if (mem pid corrupt)
          then wr (pid, m) -> p2z ;
          fwd_2c2z in fwd_2c2z)
in 0
(*let execUC = lam e, p, f, a .
  nu p2f, f2p,
     p2a, a2p,
     a2f, f2a . (
       let sid = 999 in
       let corrupt = {} in )
in
let A = lam sid . () in
let F = lam sid .
  letrec loop =
    let (pid, m) = rd ?p2f in
      print (m ++ " from " ++ show pid) ;
      wr (pid, "received") -> ?f2p ;
      loop in loop
in      
let P = lam sid, chan. |> (wr (0, "foo") -> ?p2f ; print (rd chan)) ;
                       |> (wr (1, "bar") -> ?p2f ; print (rd chan))
in
execUC () P F A*)