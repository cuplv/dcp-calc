let execUC = lam e, p, f, a .
  nu p2f, f2p,
     p2a, a2p,
     a2f, f2a . (
       let ?p2f, ?f2p, ?p2a, ?a2p, ?a2f, ?f2a =
            p2f,  f2p,  p2a,  a2p,  a2f,  f2a in
       let sid = 999 in
       let corrupt = {} in
       let partyMap = ref [] in
       let newParty = lam pid .
         nu f2pp .
           let partyMap := (pid, [("f2p", f2pp)]) :: @partyMap ;
           if pid == 0 then
           |> (p sid f2pp) in
       let getParty = lam pid .
         if (not (mem pid @partyMap)) then newParty pid ;
         @partyMap.pid in
       |> (letrec fwdf2p = 
             let (pid, m) = rd f2p in
               if (mem pid corrupt) then wr (pid, m) -> p2a
               else wr m -> (getParty pid)."f2p" ; fwdf2p in
             fwdf2p) ;
       |> (a sid) ;
       |> (f sid) ;
       |> (getParty 0 ; ())
  )
in
let A = lam sid . () in
let F = lam sid .
  letrec loop =
    let (pid, m) = rd ?p2f in
      print (m ++ " from " ++ show pid) ;
      wr (pid, "received") -> ?f2p ;
      loop in loop
in      
let P = lam sid, chan. |> (wr (0, "foo") -> ?p2f ; print (rd chan)) ;
                       |> (wr (1, "bar") -> ?p2f ; print (rd chan))
in
execUC () P F A