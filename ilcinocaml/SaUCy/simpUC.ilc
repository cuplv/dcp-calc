let execUC = lam e, p, f, a .
  nu p2f, f2p,
     p2a, a2p,
     a2f, f2a, . (
       let corrupt = {} in
       a sid .|.
       f sid .|.
       let partyMap = ref [] in
       let newParty = (lam pid .
         nu f2pp .
           let partyMap := (pid, [("f2p", f2pp)]) :: @partyMap ;
           letrec fwdf2p =
             let m = rd pp2f in wr (pid, m) -> f2p ; fwdf2p in
           () .|. fwdf2p) in
       let getParty = lam pid .
         (* polymorphic mem *)
         if (not (mem pid partyMap)) then newParty pid ;
         partyMap.pid in
       letrec fwdf2p = 
         let (pid, m) = rd f2p in
           if (mem pid corrupt) then wr (pid, m) -> p2a
           else wr m -> (getParty pid)."f2p" ; fwdf2p in
       fwdf2p
     )
in 0