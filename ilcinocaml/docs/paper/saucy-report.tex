\def\OPTIONConf{0}%
\def\OPTIONArxiv{0}%
%
\documentclass{llncs}
\usepackage{joshuadunfield}
\usepackage{boxedminipage}
\usepackage{goodcharter} %% XXX -- Check that ETAPS permits this font!
%\usepackage{euler}
\input{defs}
\usepackage{enumitem}

\newcommand{\mc}[1]{\mathcal{{#1}}}
\newcommand{\parheader}[1]{\noindent\emph{\textbf{{#1}.}}}

\title{SaUCy: Super Amazing Universal ComposabilitY}
\author{Kevin Liao}
\institute{}

\begin{document}

\maketitle

\begin{abstract}
This is a report for class.
\end{abstract}

\section{Introduction}

Proving that a protocol is secure is an essential component in cryptographic
protocol design. To do so, we must rigorously define what security means, and
then demonstrate that the protocol lives up to the definition. Initial security
definitions for cryptographic tasks consider only a standalone execution of the
protocol. While this simplifies analyses, these definitions are insufficient
when analyzing the protocol in more complex contexts. Extended security
definitions have been formulated to remedy these drawbacks, but are often
complex and ad hoc.

The Universal Composability (UC) framework by
Canetti~\cite{canetti2001universally} is a general framework for reasoning about
the security of practically any cryptographic protocol in a unified and
systematic way. The idea is to formulate a security definition and analyze the
protocol as in the standalone model, but to additionally show that the protocol
composes securely with other arbitrary protocols, i.e.,\ the protocol is secure
in \emph{any context}. The benefit of composability is that complex, UC-secure
protocols can then be modularly constructed from smaller UC-secure ``building
blocks''.

While universally composable security is a powerful guarantee, elaborating UC
proofs is highly nontrivial. They are notoriously complex and exist primarily as
``pen-and-paper'' proofs, which makes many of them essentially
unverifiable. Thus, the goal of this work is to place the UC framework on a
proper analytic foundation by developing computer-aided tools and techniques for
elaborating UC proofs.\smallskip

\parheader{Contributions} The main contributions of this work are the
following:
\begin{enumerate}
\item We design and implement a programming language called the Interactive
Lambda Calculus (ILC for short) for constructing algorithmic entities within the
UC execution model.
\item We implement the UC execution model in ILC along with a ``library'' of
example algorithmic entities (ideal functionalities).
\item We build a compiler for translating ILC programs into
EasyCrypt~\cite{barthe2011computer} modules, which allows us to construct
cryptographic proofs using EasyCrypt's interactive theorem proving facilities.
\end{enumerate}

\parheader{Organization} In Section \ldots

\section{Background}

Demonstrating that a protocol ``does its job securely'' is an essential component in
cryptographic protocol design. One main challenge in formulating the security of
cryptographic protocols is capturing threats coming from the execution
environment. Another challenge is coming up with security definitions that allow
building and analyzing large cryptographic protocols from simpler building
blocks while preserving security. Addressing both of these challenges is the focus of
the Universal Composability framework.

Previous definitions of security, which considered only standalone execution or
sequential execution of protocols, have been shown to be insufficient in many
contexts where protocols are deployed within more general environments. Extended
security definitions which directly represent a given environment were also
insufficient, often complex and limited in scope.

In Universal Composability, protocols are analyzed \emph{in vitro}, that is, in
isolation as a single protocol instance, which simplifies the
analysis. Security \emph{in vivo}, that is, in realistic settings where the
protocol may run concurrently with other protocols, is guaranteed by making sure
security is preserved under a general composition operation on protocols.

The high-level approach for determining whether a protocol is secure for some
cryptographic task goes back to~\cite{goldreich1987play}. First envision
an \emph{ideal protocol} $\phi$ that is secure by construction for carrying out the cryptographic task. In the ideal protocol, parties hand their
inputs to a trusted party, called an \emph{ideal functionality} $\mc{F}$, who locally
computes and hands to each party their corresponding output. We can think of
this ideal protocol as a formal specification of the security
requirements of the task. Then, we say that a \emph{real world} protocol $\pi$
is secure if it \emph{realizes} (emulates) $\phi$. Specifically, for any
real world adversary $\mc{A}$, there exists an ideal process adversary $\mc{S}$
(called a simulator), such that the output of running $\pi$ with $\mc{A}$ is
indistinguishable from the output of running $\phi$ with $\mc{S}$.

This security suffices for achieving standalone security, in
which a single protocol instance runs in isolation, but may be
composed \emph{sequentially} (but not concurrently) with other protocol
instances. To generalize secure composition to the concurrent setting, the UC
framework adds a new algorithmic entity to the setup described above, called
the \emph{environment}. Intuitively, the environment represents everything
external to the current protocol execution. Additionally, the UC framework has a
different notion of emulation. Namely, the environment $\mc{E}$ can interact
freely with the adversary $\mc{A}$ throughout the protocol execution. Thus, the
environment ``interactively distinguishes'' between whether it is interacting
with the real-world setup with $\pi$ and $\mc{A}$ or the ideal-world setup with
$\phi$ and $\mc{S}$. We say that $\pi$ UC-realizes $\phi$ if for all
environments $\mc{E}$ and for all adversaries $\mc{A}$, there exists a simulator
$\mc{S}$ such that $\mc{E}$ cannot tell with greater than negligible probability
whether it is interacting with $\pi$ and $\mc{A}$ or $\phi$ and $\mc{S}$.

\begin{definition}[Protocol Emulation]
Let $\pi$ and $\phi$ be protocols. We say that $\pi$ UC-emulates $\phi$ if for
any PPT adversary $\mc{A}$ there exists a PPT adversary $\mc{S}$ such that for
any balanced PPT environment $\mc{E}$ we have:
\begin{equation*}
\textsc{EXEC}_{\phi, \mc{S}, \mc{E}} \approx \textsc{EXEC}_{\pi, \mc{A}, \mc{E}}.
\end{equation*}
\end{definition}

\begin{theorem}[Universal composition: General statement]
Let $\rho$, $\pi$, $\phi$ be PPT protocols such that $\pi$ UC-emulates $\phi$
and both $\pi$ and $\phi$ are subroutine respecting. Then protocol
$\rho^{\phi \rightarrow \pi}$ UC-emulates protocol $\rho$.
\end{theorem}

\section{SaUCy Execution}

\input{defn_execuc}

\section{ILC Language Definition}

\section{Related Work}

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{saucy-report}

\appendix

\begin{figure}[htbp]
  \centering

\begin{grammar}
  Value Types
  & $A,B$
      &$\bnfas$&
      $x$ & Value variable
      \\ &&& $\bnfaltbrk \Unit$ & Unit value
      \\ &&& $\bnfaltbrk \Nat$         & Natural number
      \\ &&& $\bnfaltbrk A ** B$ & Product
      \\ &&& $\bnfaltbrk A + B$ & Sum type
      \\ &&& $\bnfaltbrk *! A$ & Intuitionistic type
      \\ &&& $\bnfaltbrk \tyRd{A}$ & Read channel
      \\ &&& $\bnfaltbrk \tyWr{A}$ & Write channel
      \\ &&& $\bnfaltbrk \tyU{C}$ & Thunk type
  \\[1ex]
  Computation Types
  & $C, D$
      &$\bnfas$ & 
             $A -> C$ & Value-consuming computation
      \\ &&& $\bnfaltbrk \tyF{A}$ & Value-producing computation
  \\[1ex]
  Linear Typing Contexts
  & $\Delta$
     &$\bnfas$& $\emptyctxt \bnfalt \Delta,x:A$
  \\
  Intuitionisitic Typing Contexts
  & $\Gamma$
     &$\bnfas$& $\emptyctxt \bnfalt \Gamma,x:A$
\end{grammar}

  \caption{Syntax of types and typing contexts}
  \label{fig:expr}
\end{figure}


\begin{figure}[htbp]
  \centering

\begin{grammar}
  Values
  & $v$
      &$\bnfas$&
      $x$
      \\ &&& $\bnfaltbrk \vUnit$ & Unit value
      \\ &&& $\bnfaltbrk n$         & Natural number
      \\ &&& $\bnfaltbrk \vPair{v_1}{v_2}$ & Pair of values
      \\ &&& $\bnfaltbrk \vInj{i}{v}$ & Injected value
      \\ &&& $\bnfaltbrk \vChan{c}$ & Channel (either read or write end)
      \\ &&& $\bnfaltbrk \vThunk{e}$ & Thunk (suspended, closed expression)
  \\[1ex]
  Expressions
  & $e$
      &$\bnfas$&
             $\Split{v}{x_1}{x_2}{e}$ & Pair elimination
      \\ &&& $\bnfaltbrk \Case{v}{x_1}{e_1}{x_2}{e_2}$ & Injection elimination
      \\ &&& $\bnfaltbrk \Ret{v}$ & Value-producing computation
      \\ &&& $\bnfaltbrk \Let{e_1}{x}{e_2}$ & Let-binding/sequencing
      \\ &&& $\bnfaltbrk \eApp{e}{v}$ & Function application
      \\ &&& $\bnfaltbrk \lam{x} e$ & Function abstraction
      \\ &&& $\bnfaltbrk \eForce{v}$ & Unsuspend (force) a thunk
      \\ &&& $\bnfaltbrk \eWr{v_1}{v_2}$ & Write channel~$v_1$ with value~$v_2$
      \\ &&& $\bnfaltbrk \eRd{v}$ & Read channel~$v$
      \\ &&& $\bnfaltbrk \eNu{x}{e}$ & Allocate channel as~$x$ in~$e$      \\ &&& $\bnfaltbrk e_1 *&& e_2$ & Fork~$e_1$, continue as~$e_2$
      \\ &&& $\bnfaltbrk e_1 *|| e_2$ & External choice between~$e_1$ and~$e_2$
\end{grammar}

  \caption{Syntax of values and expressions}
  \label{fig:expr}
\end{figure}


\begin{figure}[htbp]
{
  \centering

\begin{grammar}
  Modes & $m,n,p$ &$\bnfas$& $\Wm \bnfalt \Rm \bnfalt \Vm$ & (Write, Read and Value) 
\end{grammar}

\judgbox{m || n => p}{~~The parallel composition of modes $m$ and $n$ is mode~$p$.}
\begin{mathpar}
\Infer{sym}{m || n => p}{n || m => p}
\and \Infer{wv}{ }{\Wm || \Vm => \Wm}
\and \Infer{wr}{ }{\Wm || \Rm => \Wm}
\and \Infer{rr}{ }{\Rm || \Rm => \Rm}
\end{mathpar}
\\[2mm]
\judgbox{m ;; n => p}{~~The sequential composition of modes $m$ and $n$ is mode~$p$.}
\begin{mathpar}
\and \Infer{v$\ast$}{ }{\Vm ;; n => n}
\and \Infer{wv}{ }{\Wm ;; \Vm => \Wm}
\and \Infer{r$\ast$}{ }{\Rm ;; n => \Rm}
\and \Infer{wr}{ }{\Wm ;; \Rm => \Wm}
\end{mathpar}
}
Note that in particular, the following mode compositions are \emph{not derivable}:
\begin{itemize}
\item $\Wm || \Wm => p$ is \emph{not} derivable for any mode~$p$
\item $\Wm ;; \Wm => p$ is \emph{not} derivable for any mode~$p$
\end{itemize}
\caption{Syntax of modes; sequential and parallel mode composition.}
\label{fig:expr}
\end{figure}


\begin{figure}[htbp]
\centering
\judgbox{\Delta ; \Gamma |- e : C |> m}{~~Under $\Delta$ and $\Gamma$, expression~$e$ has type $C$ and mode $m$.}
\begin{mathpar}
%
\Infer{ret}
{\Delta ; \Gamma |- v : A}
{\Delta ; \Gamma |- \Ret{v} : \tyF A |> \Vm}
%
\and
%
\Infer{let}
{ m_1 ;; m_2 => m_3\\\\
\Delta_1        ; \Gamma |- e_1 : \tyF A |> m_1 \\\\
 \Delta_2, x:A ; \Gamma |- e_2 : C |> m_2
}
{\Delta_1, \Delta_2 ; \Gamma, x:A |- \Let{e_1}{x}{e_2} : C |> m_3}
%
\and
%
\Infer{ret!}
{\emptyctxt ; \Gamma |- v : A}
{\emptyctxt ; \Gamma |- \Ret{v} : \tyF (*! A) |> \Vm}
%
\and
%
\Infer{let!}
{\Delta_1 ; \Gamma |- v : *! A \\
 \Delta_2 ; \Gamma, x : A |- e : C |> m }
{\Delta_1, \Delta_2 ; \Gamma, x : A |- \LetBang{v}{x}{e} : C |> m}
%
\and
%
\Infer{lam}
{\Delta ; \Gamma |-         e :      C |> m}
{\Delta ; \Gamma |- \lam{x} e : A -> C |> m}
%
\and
%
\Infer{app}
{\Delta_1 ; \Gamma |- v : A \\
 \Delta_2 ; \Gamma |- e : A -> C |> m}
{\Delta_1, \Delta_2 ; \Gamma |- e\,v : C |> m}
%
\and
%
\Infer{nu}
{\Delta, x:\big(\tyRd A ** *!(\tyWr A)\big) ; \Gamma |- e : C |> m}
{\Delta                                 ; \Gamma |- \eNu{x}{e} : C |> m}
%
\\
%
\Infer{rd}
{\Delta; \Gamma |- v : \tyRd A}
{\Delta         |- \eRd{v} : \tyF (A ** (\tyRd A)) |> \Rm}
%
\and
%
\Infer{wr}
{\Delta_1; \Gamma   |- v_1 : \tyWr A \\
 \Delta_2; \Gamma   |- v_2 : A }
{\Delta_1, \Delta_2 |- \eWr{v_1}{v_2} : \tyF \Unit |> \Wm}
%
\\
%
\Infer{fork}
{
 m_1 || m_2 => m_3
 \\\\
 \Delta_1; \Gamma |- e_1 : C |> m_1
 \\\\
 \Delta_2; \Gamma |- e_2 : D |> m_2
}
{\Delta_1, \Delta_2 |- e_1 \xFork e_2 : D |> m_3}
%
\and
%
\Infer{choice}
{\Delta_1; \Gamma |- e_1 : C |> \Rm
           \\\\
 \Delta_2; \Gamma |- e_2 : C |> \Rm
}
{\Delta_1, \Delta_2 |- e_1 *|| e_2 : C |> \Rm}
%
\end{mathpar}
\end{figure}


\begin{figure}
\centering
\begin{grammar}
  Channels
  & $\Chans$ 
    & $\bnfas$ & $\emptyChans ~|~ \Chans, c$
    \\[2mm]
  Process pool
  & $\Procs$ 
    & $\bnfas$ & $\emptyProcs ~|~ \Procs, \proc$
    \\[2mm]
  Configurations
  & $C$
     & $\bnfas$ & $\Config{\Chans}{\Procs} $
     \\[2mm]
 Evaluation contexts
  & $E$
     & $\bnfas$ & $\Let{E}{x}{e}$
     \\ &&& $\bnfaltbrk \App{E}{v}$
     \\ &&& $\bnfaltbrk \bullet$
\\[2mm]
 Read contexts
  & $R$
     & $\bnfas$ & $\eRd{\vChan{c}} \oplus R$
     \\ &&& $\bnfaltbrk R \oplus \eRd{\vChan{c}}$
     \\ &&& $\bnfaltbrk \bullet$
\end{grammar}

\judgbox{e ---> e'}{~~Expression~$e_1$ reduces to~$e_2$.}
\begin{mathpar}
\Infer{let}
{}
{ \Let{\Ret{v}}{x}{e} ---> [v/x]e }
~~~
\Infer{app}
{}
{ \eApp{(\lam{x} e)}{v} ---> [v/x]e }
~~~
\Infer{force}
{ }
{ \eForce{\vThunk{e}} ---> e }
\and
\Infer{split}
{ }
{ \eSplit{\vPair{v_1}{v_2}}{x}{y}{e} ---> [v_1/x][v_2/y]e }
~~~
\Infer{case}
{ }
{ \eCase{\vInj{i}{v}}{x_1}{e_1}{x_2}{e_2} ---> e_i[v/x_i] }
\end{mathpar}

\judgbox{C_1 \equiv C_2}{~~Configurations~$C_1$ and $C_2$ are equivalent.}
\begin{mathpar}
\Infer{permProcs}
{  \Procs_1 \equiv_\textsf{perm} \Procs_2 }
{ \Config{\Chans}{\Procs_1} \equiv \Config{\Chans}{\Procs_2} }
\end{mathpar}

\judgbox{C_1 ---> C_2}{~~Configuration~$C_1$ reduces to $C_2$.}
\begin{mathpar}
\Infer{local}{ e ---> e' }
{ \Config{\Chans}{\Procs, E[e]} ---> \Config{\Chans}{\Procs, E[e]'} }
~~~
\Infer{fork}{ ~ }
{ \Config{\Chans}{\Procs, E[ e_1 \xFork e_2 ] } ---> \Config{\Chans}{\Procs, e_1, E[ e_2 ] } }
\and
\Infer{congr}{
C_1 \equiv C_1' 
\\
C_1' ---> C_2
\\
C_2 \equiv C_2'
}
{ C_1 ---> C_2' }
\and
\Infer{nu}{ c \notin \Chans }
{ \Config{\Chans}{\Procs,E[\eNu{x}{e}]} ---> \Config{\Chans, c}{\Procs, E[ [\vPair{\vChan{c}}{\vChan{c}} / x] e ]} }
\and
\Infer{rw}{ ~ }
{ \Config{\Chans}{\Procs,E_1[R[\eRd{\vChan{c}}] ],E_2[\eWr{\vChan{c}}{v}]} ---> \Config{\Chans}{\Procs,E_1[v],E_2[\vUnit]} }
\and
\end{mathpar}
\end{figure}

\end{document}
