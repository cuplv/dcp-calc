\def\OPTIONConf{0}%
\def\OPTIONArxiv{0}%
%
\documentclass{llncs}
\input{defs}

\title{SaUCy Reference: Reliable Broadcast}
\author{}
\institute{}

\begin{document}

\maketitle

\section{Overview}

Adaptively secure broadcast~\cite{garay2011adaptively}. Bracha~\cite{bracha1987asynchronous}.

\section{Ideal Functionalities}

\begin{comment}
\begin{boxdef}{Functionality}{$\Func{BC}$}
  $\Func{BC}$ interacts with an adversary $\mc{S}$ and a set $\mc{P} = \{
  P_1, \ldots, P_n \}$ of parties.
  \begin{enumerate}
    \item Upon receiving $({\sf Bcast}, sid, m)$ from $P_i$, send $({\sf Bcast},
  sid, P_i, m)$ to all parties in $\mc{P}$ and to $\mc{S}$.
  \end{enumerate}
\end{boxdef}


\begin{boxdef}{Functionality}{$\Func{RBC}$}
  $\Func{RBC}$ interacts with an adversary $\mc{S}$ and a set $\mc{P} = \{
  P_1, \ldots, P_n \}$ of parties.
  \begin{enumerate}
    \item Upon receiving $({\sf Bcast}, sid, m)$ from $P_i$, leak $({\sf Bcast},
  sid, P_i, m)$ to $\mc{S}$.
  
    \item Upon receiving $m'$ from $\mc{S}$, do:
    
    \begin{itemize}
      \item If $P_i$ is corrupted, send $({\sf Bcast}, sid, P_i, m')$ to all
  parties in $\mc{P}$.
  
      \item If $P_i$ is not corrupted, send $({\sf Bcast}, sid, P_i, m)$ to all
  parties in $\mc{P}$.
    \end{itemize}
  \end{enumerate}
\end{boxdef}
\end{comment}

\begin{boxdef}{Functionality}{$\Func{ACAST}$}
  $\Func{ACAST}$ interacts with an adversary $\mc{S}$ and a set $\mc{P} = \{
  P_1, \ldots, P_N \}$ of parties.
  \begin{enumerate}
    \item Upon receiving $({\sf Bcast}, sid, m)$ from $P_D$:
    
    \begin{itemize}
      \item If $P_D$ is honest, then, for each $P_i$ in $\mc{P}$, send $({\sf
      Bcast}, sid, P_i, m)$ {\bf eventually}.
      
      \item If $P_D$ is corrupted, then {\bf possibly}, for each $P_i$ in $\mc{P}$,
      send $({\sf Bcast}, sid, P_i, m)$ {\bf eventually}.
      \end{itemize}
  \end{enumerate}
\end{boxdef}

\begin{comment}
\begin{boxdef}{Functionality}{$\Func{ACAST}(D, P_1, \ldots, P_N)$}
  Assume $N > 3f$ for $f$ Byzantine failures.
  \begin{enumerate}[leftmargin=0cm]
    \item[] On send(x) from $D$:
    \begin{itemize}
      \item[] If $D$ is honest:
      \begin{itemize}
        \item[] For each $P_i$:
        \begin{itemize}
          \item[] Eventually send(x) to $P_i$.
        \end{itemize}
      \end{itemize}

      \item[] If $D$ is corrupt:
      \begin{itemize}
      \item[] Possibly:
        \begin{itemize}
          \item[] For each $P_i$:
          \begin{itemize}
            \item[] Eventually send(x) to $P_i$.
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{enumerate}
\end{boxdef}

\begin{boxdef}{ILC}{$\Func{ACAST}$}
\lstinputlisting[style=ilc]{listings/F_acast.ilc}
\end{boxdef}
\end{comment}

\section{Protocol Definition}

\begin{boxdef}{Protocol}{$\Pi_{\sf Bracha}$}
  $\Pi_{\sf Bracha}$ interacts with a set $\mc{P} = \{ P_1, \ldots, P_n \}$ of
  parties and can tolerate up to $f$ failures.
  \begin{enumerate}
    \item Upon receiving $({\sf Value}, v)$ from $P_i$, send $({\sf Initial},
  v)$ to all parties in $\mc{P}$.
  
    \item Upon receiving an $({\sf Initial}, v)$ message or
  $\ceil{\frac{n+f}{2}}$ $({\sf Echo}, v)$ messages or $\ceil{\frac{f+1}{2}}$
  $({\sf Ready}, v)$ messages, send $({\sf Echo}, v)$ to all parties in
  $\mc{P}$.

    \item Upon receiving $\ceil{\frac{n+f}{2}}$ $({\sf Echo}, v)$ messages or
  $\ceil{\frac{f+1}{2}}$ $({\sf Ready}, v)$ messages, send $({\sf Ready}, v)$ to
  all parties in $\mc{P}$.

    \item Upon receiving $\ceil{\frac{f+1}{2}}$ $({\sf Ready}, v)$ messages,
    accept $v$.
  \end{enumerate}
\end{boxdef}

\section{Protocol Emulation}

\begin{theorem}
Protocol $\Pi_{\sf Bracha}$ $t$-securely realizes the functionality $\Func{ACAST}$
for $t < N/3$.
\end{theorem}

\begin{proof-sketch}
Let $\mc{A}$ be an adversary attacking $\Pi_{\sf Bracha}$. We build a
corresponding simulator $\mc{S}$ as follows.

\begin{boxdef}{Simulator}{$\mc{S}_{\sf ACAST}$}
$\mc{S}$ invokes $\mc{A}$ and does the following:
\begin{enumerate}
  %\item $\mc{S}$ simulates all players in the computation.
  \item Whenever $\mc{A}$ requests to corrupt some $P_i \in \mc{P}$, corrupt $P_i$
  and sends the internal state of $P_i$ to $\mc{A}$. Hereafter, $\mc{S}$ has
  $P_i$ follow $\mc{A}$'s instruction.
  \item Whenever $\mc{A}$ sends a message to the environment $\mc{Z}$, $\mc{S}$
  forwards this message to $\mc{Z}$.
\end{enumerate}
\end{boxdef}

\noindent If an honest party $p_i$ accepts $m_i = m$, then in the ideal execution, $P_D$
sent $m$ to $\Func{ACAST}$, even if $P_D$ was corrupted. Otherwise, if $P_i$
accepts nothing, then $\mc{S}$ instructed $P_D$ to send $m_i \neq m$ to
$\Func{ACAST}$. The correctness of $\Pi_{\sf
Bracha}$~\cite{bracha1987asynchronous} implies that $P_i$ accepts nothing only
when $P_D$ is actively corrupted. Verifying that $\textsc{Exec}[\Pi_{\sf
Bracha}, \mc{A}, \mc{Z}] \approx \textsc{Exec}[\Func{ACAST}, \mc{S}, \mc{Z}]$ is left
as an exercise to the reader because I have no idea what I'm doing.
\end{proof-sketch}
    
\bibliographystyle{plain}
\bibliography{reliable-broadcast}

\end{document}
