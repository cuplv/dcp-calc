embed {{ tex-preamble }}

metavar name {{ tex n }} , x, y, f, g ::= {{ com variables }}
indexvar i, j ::= {{ com Indicies }}

grammar
e :: 'e_' ::= {{ com Expressions (Computations) }}
   |  split ( v, x . y . e )         :: :: split {{ com split components of a pair }}
   |  case ( v , x1 . e1 , x2 . e2 ) :: :: case {{ com case analysis of injection }}

   |  \ x . e              :: :: lam {{ com function abstraction }}
   |  e v                  :: :: app {{ com function application }}

   |  ret v                :: :: ret {{ com computation termination }}
   |  let x = e1 in e2     :: :: let {{ com computation sequencing }}

   |  fix f . e            :: :: fix  {{ com recursive computation [[e]] named by [[f]] }}

   | force v               :: :: force

   | roll e                :: :: roll
   | unroll e              :: :: unroll

   | e1 || e2              :: :: par {{ tex [[e1]]~{\mathrel{||} }~[[e2]] }}
   | e1 ++ e2              :: :: choice {{ tex [[e1]]~{\oplus}~[[e2]] }}
   | rd v                  :: :: read
   | v1 --> v2             :: :: write {{ tex [[v1]] \rightarrow [[v2]] }}
   | nu x . e              :: :: nu {{ tex \nu [[x]] . [[e]] }}

%   | e1 ; e2               :: :: seq 
%   | x <--  v ;  e        :: :: read {{ tex [[x]] \leftarrow [[v]] ; [[e]] }}

   | ( e ) :: M :: paren {{ com parenthesized (syntactic sugar) }}

   | e [ v  / x ] :: M :: subst_val  {{ com [[e]] with [[x]] substituted with [[v]] }}
   | e [ e' / f ] :: M :: subst_fix  {{ com [[e]] with [[f]] substituted with [[e']] }}

v :: 'v_' ::= {{ com Values }}
   | ( v ) :: M :: paren
   | ()    :: :: unit
   | ( v1 , v2 ) :: :: pair {{ com Value pair. }}
   |  inj i v    :: :: inj {{ tex [[inj]]_{[[i]]}\,[[v]] }} {{ com Injected value. }}
   | thunk e     :: :: thunk

grammar
A, B :: 'A_' ::= {{ com Value types }}
      | Unit :: :: Unit {{ tex \textsf{Unit} }}
      | A + B :: :: sum
      | A * B :: :: prod
      | Ch name A :: :: Chan  {{ tex \textsf{Ch}\,[[name]]\,[[A]] }}
      | U C @ eps :: :: thunk {{ tex \textsf{U}\,[[C]]\,@\,[[eps]] }}
      | U_ C @ eps :: :: thunk_ {{ tex \underbar{ \textsf{U} }{}~{[[C]]}~@~[[eps]] }}      

C, D :: 'C_' ::= {{ com Computation types }}
      | A -> C :: :: arrow
      | F A  :: :: free {{ tex \textsf{F}\,[[A]] }}

G {{ tex \Gamma }} :: 'G_' ::= {{ com Typing context }}
   | emp        :: :: emp
   | G , x : A  :: :: vartype
   | G , name   :: :: nametype
   | G1 , G2    :: M :: seq
   | ( send G ) :: M :: send {{ tex \lfloor[[G]]\rfloor_{\textsf{send} } }}

terminals :: 'terminals_' ::=
    | emp    :: :: emp            {{ tex \cdot }}
    | \      :: :: lambda         {{ tex \lambda }}
    | !!     :: :: Downarrow      {{ tex \Downarrow }}
    | |-     :: :: turnstile      {{ tex \vdash }}
    | _|_    :: :: bottom      {{ tex \bot }}
    | ->     :: :: arrowright     {{ tex \rightarrow }}
    | U      :: :: union          {{ tex {\cup} }}
    | -->    :: :: longarrowright {{ tex \longrightarrow }}
    | <--    :: :: longarrowleft {{ tex \longleftarrow }}
    | *      :: :: times          {{ tex \times }}
    | mu     :: :: mu             {{ tex \mu }}



eps {{ tex \epsilon }} :: 'eps_' ::= {{ com Effects }}
   | R       :: :: r
   | W R     :: :: wr

R :: 'R_' ::= {{ com Read sets }}
   | emp          :: :: emp {{ tex \bullet }}
   | Rd name      :: :: singleton_rd
   | R1 _|_ R2    :: :: disjointunion_rd
   | R1 U R2      :: :: union_rd
   | R1 ; R2      :: :: seq
   | ( R )        :: M :: paren

defns
J :: '' ::=


defn
A send :: :: Sendable :: 'S_' {{ com [[A]] is sendable }} {{ tex [[A]]~\textsf{send} }}
by

--------- :: unit
Unit send

A send
B send
---------- :: sum
A + B send

A send
B send
---------- :: prod
A * B send

------------------ :: thunk
U C @ eps send

defn
G |- v : A
:: :: JVType :: 'TV_'
{{ com Typing: Under [[G]], value [[v]] has type [[A]]. }}
by

------------- :: unit
G |- () : Unit 

G |- v1 : A
G |- v2 : B
---------------------- :: prod
G |- (v1, v2) : A * B

G |- v : Ai
---------------------- :: sum
G |- inj i v : A1 + A2

(send G) |- e : C @ eps
------------------------- :: thunk
G |- thunk e : U C @ eps

G |- e : C @ eps
------------------------- :: thunk_
G |- thunk e : U_ C @ eps

defn
G |- e : C @ eps
:: :: JType :: 'T_'
{{ com Typing: Under [[G]], expression [[e]] has type [[C]] and effect [[eps]]. }}
{{ tex [[G]] [[|-]] [[e]] : [[C]]~@~[[eps]] }}
by

G |- v : U C @ eps
----------------------- :: force
G |- force v : C @ eps

G |- v : U_ C @ eps
----------------------- :: force_
G |- force v : C @ eps

G |- v : A
G |- e : A -> C @ eps
------------------------ :: app
G |- e v : C @ eps

G, x:A |- e : C @ eps
-------------------------------- :: abs
G |- \x.e : A -> C @ eps

G |- v : A * B
G, x:A, y:B |- e : C @ eps 
---------------------------------- :: split
G |- split (v, x.y.e) : C @ eps

G, name, x : Ch name A |- e : C @ eps
---------------------------------- :: mkchan
G |- nu x . e : C @ eps

G |- e1 : C @ R1
G |- e2 : C @ R2
------------------------------ :: par
G |- e1 || e2 : C @ R1 _|_ R2

G |- e1 : C @ R11 ; R12
G |- e2 : C @ R21 ; R22
--------------------------------------------------- :: choice
G |- e1 ++ e2 : C @ (R11 _|_ R12) ; (R12 U R22)

G |- e : C @ R1 ; R2
------------------ :: forgetSeq
G |- e : C @ R1 U R2

G |- v : A
-------------------------- :: free
G |- ret v : F A @ emp

G        |- e1 : F A @ R1
G, x : A |- e2 : C   @ W R2
------------------------------------------ :: RWR
G |- let x = e1 in e2 : C @ R1 ; R2

G        |- e1 : F A @ W R1
G, x : A |- e2 : C   @ R2
---------------------------------------- :: WRR
G |- let x = e1 in e2 : C @ W (R1 U R2)

G |- v : Ch name A
------------------------------ :: R
G |- rd v : F A @ Rd name

G |- v1 : A
G |- v2 : Ch name A
------------------------------- :: W
G |- v1 --> v2 : F Unit @ W R
