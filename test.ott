embed {{ tex-preamble }}

metavar name {{ tex n }} , x, y, f, g ::= {{ com variables }}
indexvar i, j ::= {{ com Indicies }}

grammar
e :: 'e_' ::= {{ com Expressions (Computations) }}
   |  x                :: :: var  {{ com free variable }}
   |  ()               :: :: unit {{ com unit value }}
   |  inj i e          :: :: inj {{ tex [[inj]]_{[[i]]}\,[[e]] }} {{ com injection of [[e]], indexed by [[i]] }}
   |  ( e1 , e2 )      :: :: pair {{ com pair }}
   |  split ( v, x . y . e ) :: :: split {{ com split components of a pair }}
   |  case ( v , x1 . e1 , x2 . e2 ) :: :: case {{ com case analysis of injection }}
   |  \ x . e          :: :: lam {{ com function abstraction }}
   |  e1 e2            :: :: app {{ com function application }}

   |  let x = e1 in e2 :: :: let {{ com computation sequencing }}
   |  fix f . e       :: :: fix  {{ com recursive computation [[e]] named by [[f]] }}

   | roll e   :: :: roll
   | unroll e :: :: unroll

   | ( e ) :: M :: paren {{ com parenthesized (syntactic sugar) }}

   | e [ v  / x ] :: M :: subst_val  {{ com [[e]] with [[x]] substituted with [[v]] }}
   | e [ e' / f ] :: M :: subst_fix  {{ com [[e]] with [[f]] substituted with [[e']] }}

   | e1 || e2              :: :: par {{ tex [[e1]]~{\mathrel{||} }~[[e2]] }}
   | e1 ++ e2              :: :: choice {{ tex [[e1]]~{\oplus}~[[e2]] }}
%   | x <--  v ;  e        :: :: read {{ tex [[x]] \leftarrow [[v]] ; [[e]] }}
   | rd v                  :: :: read
   | v1 --> v2             :: :: write {{ tex [[v1]] \rightarrow [[v2]] }}
   | nu x . e              :: :: nu {{ tex \nu [[x]] . [[e]] }}
   | e1 ; e2               :: :: seq 

v :: 'v_' ::= {{ com Values }}
   | ( v ) :: M :: paren
   | ()    :: :: unit
   | ( v1 , v2 ) :: :: pair {{ com Value pair. }}
   |  inj i v    :: :: inj {{ tex [[inj]]_{[[i]]}\,[[v]] }} {{ com Injected value. }}
   | \ x . e     :: :: lambda {{ com Function abstraction. }}

grammar
A, B :: 'A_' ::= {{ com Value types }}
      | Unit :: :: Unit {{ tex \textsf{Unit} }}
      | A + B :: :: sum
      | A * B :: :: prod
      | Ch name A :: :: Chan  {{ tex \textsf{Ch}\,[[name]]\,[[A]] }}
      | U C @ eps :: :: thunk {{ tex \textsf{U}\,[[C]]\,@\,[[eps]] }}
      | U_ C @ eps :: :: thunk_ {{ tex \underbar{ \textsf{U} }{}~{[[C]]}~@~[[eps]] }}      

C, D :: 'C_' ::= {{ com Computation types }}
      | A -> C :: :: arrow
      | F A  :: :: free {{ tex \textsf{F}\,[[A]] }}

G {{ tex \Gamma }} :: 'G_' ::= {{ com Typing context }}
   | emp        :: :: emp
   | G , x : A  :: :: vartype
   | G , name   :: :: nametype
   | G1 , G2    :: M :: seq

terminals :: 'terminals_' ::=
    | emp    :: :: emp            {{ tex \cdot }}
    | \      :: :: lambda         {{ tex \lambda }}
    | !!     :: :: Downarrow      {{ tex \Downarrow }}
    | |-     :: :: turnstile      {{ tex \vdash }}
    | _|_    :: :: bottom      {{ tex \bot }}
    | ->     :: :: arrowright     {{ tex \rightarrow }}
    | U      :: :: union          {{ tex {\cup} }}
    | -->    :: :: longarrowright {{ tex \longrightarrow }}
    | <--    :: :: longarrowleft {{ tex \longleftarrow }}
    | *      :: :: times          {{ tex \times }}
    | mu     :: :: mu             {{ tex \mu }}



eps {{ tex \epsilon }} :: 'eps_' ::= {{ com Effects }}
   | R       :: :: r
   | W R     :: :: wr

R :: 'R_' ::= {{ com Read sets }}
   | Rd name      :: :: singleton_rd
   | R1 _|_ R2    :: :: disjointunion_rd
   | R1 U R2      :: :: union_rd
   | R1 ; R2      :: :: seq
   | ( R )        :: M :: paren

defns
J :: '' ::=


defn
A send :: :: Sendable :: 'S_' {{ com Sendable }} {{ tex [[A]]~send }}
by

--------- :: send_unit
Unit send


defn
G |- v : A
:: :: JVType :: 'TV_'
{{ com Typing: Value [[v]] has type [[A]] in env [[G]] }}
by

------------- :: unit
G |- () : Unit 


defn
G |- e : C @ eps
:: :: JType :: 'T_'
{{ com Typing: Expression [[e]] has effect [[eps]] in env [[G]] }}
{{ tex [[G]] [[|-]] [[e]] : [[C]]~@~[[eps]] }}
by

G |- v : A * B
G, x:A, y:B |- e : C @ eps 
---------------------------------- :: split
G |- split (v, x.y.e) : C @ eps

G, name, x : Ch name A |- e : C @ eps
---------------------------------- :: mkchan
G |- nu x . e : C @ eps

G |- e1 : C @ R1
G |- e2 : C @ R2
------------------------------ :: par
G |- e1 || e2 : C @ R1 _|_ R2

G |- e1 : C @ R11 ; R12
G |- e2 : C @ R21 ; R22
--------------------------------------------------- :: choice
G |- e1 ++ e2 : C @ (R11 _|_ R12) ; (R12 U R22)

G        |- e1 : F A @ R1
G, x : A |- e2 : C   @ W R2
------------------------------------------ :: RWR
G |- let x = e1 in e2 : C @ R1 ; R2

G        |- e1 : F A @ W R1
G, x : A |- e2 : C   @ R2
---------------------------------------- :: WRR
G |- let x = e1 in e2 : C @ W (R1 U R2)

G |- v : Ch name A
------------------------------ :: R
G |- rd v : F A @ Rd name

G |- v1 : A
G |- v2 : Ch name A
------------------------------- :: W
G |- v1 --> v2 : F Unit @ W R
