embed {{ tex-preamble }}

metavar a {{ tex \alpha }}, b {{ tex \beta }} ::= {{ com index variables }}
metavar x, y, f, g ::= {{ com variables }}
indexvar i, j ::= {{ com Indicies }}

grammar
n :: 'n_' ::= {{ com Names }}
  | a :: :: var

grammar
e :: 'e_' ::= {{ com Expressions (Computations) }}
   |  split ( v, x . y . e )         :: :: split {{ com split components of a pair }}
   |  case ( v , x1 . e1 , x2 . e2 ) :: :: case {{ com case analysis of injection }}

   |  \ x . e              :: :: lam {{ com function abstraction }}
   |  e v                  :: :: app {{ com function application }}

   |  ret v                :: :: ret {{ com computation termination }}
   |  let x = e1 in e2     :: :: let {{ com computation sequencing }}

   |  fix f . e            :: :: fix  {{ com recursive computation [[e]] named by [[f]] }}

   | force v               :: :: force

   | roll e                :: :: roll
   | unroll e              :: :: unroll

   | e1 || e2              :: :: par {{ tex [[e1]]~{\mathrel{||} }~[[e2]] }}
   | e1 ++ e2              :: :: choice {{ tex [[e1]]~{\oplus}~[[e2]] }}
   | rd v                  :: :: read
   | v1 --> v2             :: :: write {{ tex [[v1]] \rightarrow [[v2]] }}
   | nu x . e              :: :: nu {{ tex \nu [[x]] . [[e]] }}

%   | e1 ; e2               :: :: seq 
%   | x <--  v ;  e        :: :: read {{ tex [[x]] \leftarrow [[v]] ; [[e]] }}

   | ( e ) :: M :: paren {{ com parenthesized (syntactic sugar) }}

   | e [ v  / x ] :: M :: subst_val  {{ com [[e]] with [[x]] substituted with [[v]] }}
   | e [ e' / f ] :: M :: subst_fix  {{ com [[e]] with [[f]] substituted with [[e']] }}

v :: 'v_' ::= {{ com Values }}
   | ( v ) :: M :: paren
   | ()    :: :: unit
   | ( v1 , v2 ) :: :: pair {{ com Value pair. }}
   |  inj i v    :: :: inj {{ tex [[inj]]_{[[i]]}\,[[v]] }} {{ com Injected value. }}
   | thunk e     :: :: thunk

grammar
A, B :: 'A_' ::= {{ com Value types }}
      | Unit :: :: Unit {{ tex \textsf{Unit} }}
      | A + B :: :: sum
      | A * B :: :: prod
      | Ch n A :: :: Chan  {{ tex \textsf{Ch}\,[[n]]\,[[A]] }}
      | U C @ eps :: :: thunk {{ tex \textsf{U}\,[[C]]\,@\,[[eps]] }}
      | U_ C @ eps :: :: thunk_ {{ tex \underline{\textsf{U} }{}\,{[[C]]}\,@\,[[eps]] }}

C, D :: 'C_' ::= {{ com Computation types }}
      | forall a . C :: :: forall {{ tex \forall [[a]] . [[C]] }}
      | A -> C :: :: arrow
      | F A  :: :: free {{ tex \textsf{F}\,[[A]] }}
      | C [ n / a ] :: M :: nameSubst 

G {{ tex \Gamma }} :: 'G_' ::= {{ com Typing context }}
   | emp        :: :: emp
   | G , x : A  :: :: vartype
   | G , n name :: :: nametype {{ tex [[G]] , [[n]]~\textsf{name} }}
   | G1 , G2    :: M :: seq
   | ( send G ) :: M :: send {{ tex \lfloor[[G]]\rfloor_{\textsf{send} } }}

terminals :: 'terminals_' ::=
    | emp    :: :: emp            {{ tex \cdot }}
    | \      :: :: lambda         {{ tex \lambda }}
    | !!     :: :: Downarrow      {{ tex \Downarrow }}
    | |-     :: :: turnstile      {{ tex \vdash }}
    | _|_    :: :: bottom      {{ tex \bot }}
    | ->     :: :: arrowright     {{ tex \rightarrow }}
    | U      :: :: union          {{ tex {\cup} }}
    | -->    :: :: longarrowright {{ tex \longrightarrow }}
    | <--    :: :: longarrowleft {{ tex \longleftarrow }}
    | *      :: :: times          {{ tex \times }}
    | mu     :: :: mu             {{ tex \mu }}



eps {{ tex \epsilon }} :: 'eps_' ::= {{ com Effects }}
   | R       :: :: r
   | W R     :: :: wr

R :: 'R_' ::= {{ com Read sets }}
   | emp          :: :: emp {{ tex \bullet }}
   | Rd n         :: :: singleton_rd
   | R1 _|_ R2    :: :: disjointunion_rd
   | R1 U R2      :: :: union_rd
   | R1 ; R2      :: :: seq
   | ( R )        :: M :: paren


funs 
  GG ::= 

fun  
  |_ G _| send :: A :: Safe {{ com Sendable Environment }} {{ tex \lfloor [[G]] \rfloor_\textsf{send} }}
by
  |_ G, x : A _| send === |_ G _| send 
%  |_ emp _| send === emp

defns
J :: '' ::=

defn
A send :: :: Sendable :: 'S_' {{ com [[A]] is sendable }} {{ tex [[A]]~\textsf{send} }}
by

--------- :: unit
Unit send

A send
B send
---------- :: sum
A + B send

A send
B send
---------- :: prod
A * B send

------------------ :: thunk
U C @ eps send

A1 send
A2 send
------------ :: send_sum
A1 + A2 send

A1 send
A2 send
------------ :: send_prod
A1 * A2 send


------------ :: send_thunk
U C @ eps send
% Note: No conclusion for U_ C @ eps


defn
G |- v : A
:: :: JVType :: 'TV_'
{{ com Typing: Under [[G]], value [[v]] has type [[A]]. }}
by

------------- :: unit
G |- () : Unit 

G |- v1 : A
G |- v2 : B
---------------------- :: prod
G |- (v1, v2) : A * B

G |- v : Ai
---------------------- :: sum
G |- inj i v : A1 + A2

----------------------- :: var
G1, x : A, G2 |- x : A

G |- e : Ai
----------------- :: inj
G |- inj i e : A1 + A2

G |- e1 : A
G |- e2 : B
----------------- :: pair
G |- (e1,e2) : A * B

G |- e : A * B
---------------- :: fst
G |- fst e : A

G |- e : A * B
---------------- :: snd
G |- snd e : B

G |- e0 : A1 + A2
G, xi : Ai |- ei : B
------------------------- :: case
G |- case(e0,x1.e1,x2.e2) : B

G |- e1 : A -> B
G |- e2 : A
------------------ :: app
G |- e1 e2 : B

G, x:A |- e : B
---------------------- :: abs
G |- \x. e : A -> B

G |- e1 : A
G , x : A |- e2 : B
---------------------------- :: let
G |- let x = e1 in e2 : B

G , f : A |- e : A
-------------------- :: fix
G |- fix f. e : A

G |- e : A [ mu a.A / a ]
-------------------------- :: roll
G |- roll e : mu a. A

G |- e : mu a. A 
-------------------------------- :: unroll
G |- unroll e : A [ mu a.A / a ]


(send G) |- e : C @ eps
------------------------- :: thunk
G |- thunk e : U C @ eps

G |- e : C @ eps
------------------------- :: thunk_
G |- thunk e : U_ C @ eps

defn
G |- e : C @ eps
:: :: JType :: 'T_'
{{ com Typing: Under [[G]], expression [[e]] has type [[C]] and effect [[eps]]. }}
{{ tex [[G]] [[|-]] [[e]] : [[C]]~@~[[eps]] }}
by

G |- v : U C @ eps
----------------------- :: force
G |- force v : C @ eps

G |- v : U_ C @ eps
----------------------- :: force_
G |- force v : C @ eps

G |- v : A
G |- e : A -> C @ eps
------------------------ :: app
G |- e v : C @ eps

G, x:A |- e : C @ eps
-------------------------------- :: abs
G |- \x.e : A -> C @ eps

G |- v : A * B
G, x:A, y:B |- e : C @ eps 
---------------------------------- :: split
G |- split (v, x.y.e) : C @ eps

G, n name, x : Ch n A |- e : C @ eps
---------------------------------- :: mkchan
G |- nu x . e : C @ eps

G |- e1 : C @ R1
G |- e2 : C @ R2
------------------------------ :: par
G |- e1 || e2 : C @ R1 _|_ R2

G |- e1 : C @ R11 ; R12
G |- e2 : C @ R21 ; R22
--------------------------------------------------- :: choice
G |- e1 ++ e2 : C @ (R11 _|_ R12) ; (R12 U R22)

G |- e : C @ R1 ; R2
------------------ :: forgetSeq
G |- e : C @ R1 U R2

G , a name |- e : C @ eps
---------------------------- :: Iforall
G |- e : forall a . C @ eps

G1, G2 |- e : forall a . C @ eps
---------------------------------------- :: Eforall
G1, n name, G2 |- e : C [ n / a ] @ eps

G |- v : A
-------------------------- :: free
G |- ret v : F A @ emp

G        |- e1 : F A @ R1
G, x : A |- e2 : C   @ W R2
------------------------------------------ :: RWR
G |- let x = e1 in e2 : C @ R1 ; R2

G        |- e1 : F A @ W R1
G, x : A |- e2 : C   @ R2
---------------------------------------- :: WRR
G |- let x = e1 in e2 : C @ W (R1 U R2)

G |- v : Ch n A
------------------------------ :: R
G |- rd v : F A @ Rd n

G |- v1 : A
G |- v2 : Ch n A
------------------------------- :: W
G |- v1 --> v2 : F Unit @ W R
